# 문자열은 쌍 따옴표, 홑 따옴표를 사용해 생성할 수 있음
print("문자열 데이터", 'abcdef')

multi_line = """
    여러 줄의 문자열 데이터 
    쌍 따옴표 3개 또는 홑 따옴표 3개로 생성
"""
print(multi_line)

multi_line2 = """
여러 줄의 문자열 데이터 
쌍 따옴표 3개 또는 홑 따옴표 3개로 생성
"""
print(multi_line2) # 들여쓰기를 한 채로 출력하면 그 정보가 곧이곧대로 출력됨.

# 문자열 데이터의 인덱싱
# 문자열은 시퀀스(순서가 있는) 자료형으로 인덱스가 지정됨
# 인덱스는 앞에서 0부터 시작, -가 붙으면 맨 뒤에서 -1, -2, -3이 됨
s = "Hello Python"
print(s[0], s[7], s[10], s[-1], s[-3])

# 문자열 데이터의 슬라이싱
# 슬라이싱의 시작 인덱스는 포함되고 마지막 인덱스는 포함되지 않음
print(s[0: 6], s[5:-1], s[:5], s[5:], s[:])

# [::숫자] 는 지정한 숫자가 step이 되어 슬라이싱 된다.
# 양수면 앞에서 음수면 맨 뒤에서 부터 슬라이싱이 적용된다.
print(s[::2], s[::-1])

# 슬라이싱을 활용해 기존 문자열의 특정 위치의 문자열을 변경해
# 새로운 문자열을 생성함 문자열의 + 연산은 두 문자열을 연결함
print("Hi " + s[6:])

# 문자열을 50번 반복한다.
print("*" * 50, len("*" * 50))

# 문자열을 포함하고 있는지 여부 확인
print("hello" in s, "Hello" in s)

#########################################################################
# 문자열 데이터 –인덱스와 슬라이싱
# \ 는 코드가 다음 줄로 이어짐을 나타냄
str1 = "한 줄에 코드를 기술하기 어려운 경우 \
를 이용해 여러 줄에 코드를 기술할 수 있다."
print(str1)

# 문자열은 변경 불가능(Immutable)하기 때문에 아래는 에러가 남
# str1[0] = "1"

# 유니코드 타입의 문자열 리터럴 사용
# Python 3 버전은 기본적으로 유니코드 문자를 지원하지만
# Python 2 버전에서는 유니코드 사용시 모듈의 첫 줄에
#  #-*- encoding:utf-8 -*- 를 지정해야 하며 u를 문자열 앞에 붙여서
# 유니코드 문자열을 생성할 수 있으며 unicode("한글", "utf-8")를
# 사용해 유니코드 문자열을 생성할 수 있다.
# Python 2 버전에서는 <type 'unicode'> 가 출력됨
u1 = u"한글"
print(type(u1), len(u1), len("한글"))

# capitalize() 메서드는 첫 자만 대문자로 변경해 반환
# title() 메서드는 각 단어의 첫 자만 대문자로 변경해 반환
# 문자열 메서드는 원본을 바꾸는 것이 아니라 새로운 문자열을 반환
s = "   i like python like  "
print(s.upper(), s.lower(), s.capitalize(), s.title())

# count() 메서드는 지정한 문자열이 몇 번 있는지 반환
# find() 메서드는 지정한 문자열의 첫 자가 위치한 index를 반환
# rfind() 메서드는 지정한 문자열을 뒤에서 부터 찾아 index를 반환
# find(), rfind() 함수는 지정한 문자열이 없으면 -1을 반환함
print(s.count("like"), s.find("like1"), s.find("like"), s.rfind("like"))

# 문자열의 양쪽 공백을 제거해 반환하는 메서드,
# \t 도 공백으로 인식한다.
# strip("e")로 지정하면 양쪽의 e문자열을 제거 함
print(s.strip(), s.lstrip(), s.rstrip())

# 문자열을 공백으로 분리해 list 타입으로 반환하는 메서드
# \t, \n 도 공백으로 인식한다.
s1 = s.split()
print(s1, s.split(","))

# list 내부의 원소를 지정한 문자열로 연결해 반환하는 메서드
print("/".join(s1), "\n".join(s1))

# 첫 번째 인수를 두 번째 인수로 치환해 반환하는 메서드
s = "안녕 하세요 미스터"
print(s.replace("안녕 하세요", "반갑습니다."))

# 여러 줄의 문자열을 라인 단위로 분리해 list로 반환하는 메서드
print(multi_line.splitlines())

# startswith() 메서드는 지정한 문자열로 시작하면 True를 반환
# endswith() 메서드는 지정한 문자열로 끝나면 True를 반환
s = "파이썬 신나게 코딩하기.pdf"
print(s.startswith("파이썬"), " - ", s.endswith(".hwp"))

# 문자열이 숫자와 기호를 제외한 영문자, 한글 등으로
# 구성되어 있으면 True를 반환
print("알파벳ABC".isalpha(), " - ", "알파벳ABC123".isalpha())

# 문자열이 숫자로 되어있으면 True를 반환
print("12345".isnumeric(), " - ", "12삼사오".isnumeric())

# 문자열이 숫자, 영문자, 한글로 되어 있으면 True를 반환
print("123사오ABC".isalnum(), " - ", "12삼사오_ABC".isalnum())

# 03. Python 데이터 타입
# % 기호를 사용한 문자열 형식화
# 문자열 포맷팅 - 포맷 데이터가 여러 개 일 때 튜플로 지정함
print("name=%s, age=%s" %("홍길동", 25))

# 10자의 필드를 설정하여 포맷팅 지정
# 왼쪽 공간은 공백으로 채우고 오른쪽 정렬하여 출력됨
print("%10d, %10f, %10s" %(123, 123, 123))

# 전체 자리수와 소수 자리를 지정한 포맷팅
print("%3.5f, %5.2f, %1.5f" %(123, 123, 123))

# 사전(Dictionary)을 이용한 포맷팅
print("%(이름)s : %(등급)s" %{"이름": "홍길동", "등급":"A"})
print("%(이름)s : %(등급)s" %{"등급": "B", "이름":"임꺽정"})

# format 메서드를 사용한 문자열 형식화
# format() 메서드와 {} 기호를 이용해 문자열 포맷팅을 지정할 수 있다.
print("현재 {}의 최신 버전은 {}이고 오늘은 {}입니다.".
      format("파이썬", "v3.10.6", "4/11"))

# % 기호를 이용한 포맷팅은 %() 안의 데이터 순서에 따라 데이터가
# 바인딩 되지만 format() 메서드는 순서 또는 이름을 지정할 수 있다.
print("{1} {0} {2}".format("like", "I", "python"))
print("{name}님은 {age}세이고 {grade}학년 입니다.".format(\
    age=25, name="홍길동", grade=4))

# f 문자열을 이용한 문자열 형식화
# 파이썬 3.6부터는 f 문자열(f-string) 포맷팅을 사용할 수 있다.
# f 문자열 안에서 일반 변수를 그대로 지정해 포맷팅을 지정할 수 있다.
name = '어머나'; age=27; gender = '여성'
print(f'{name}의 나이는 {age}살이고 {gender} 입니다.')

# format() 메서드는 다음과 같이 일반 변수를 그대로 사용할 수 있다.
print("{0}의 나이는 {1}살이고 {2} 입니다.".format(name, age, gender))
print("{name}의 나이는 {age}살이고 {gender} 입니다."
      .format(name=name, age=age, gender=gender))